<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="ZXing for JS">

		<title>ZXing TypeScript | Decoding from camera stream</title>

		<link rel="stylesheet" rel="preload" as="style" onload="this.rel='stylesheet';this.onload=null"
			href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">
		<link rel="stylesheet" rel="preload" as="style" onload="this.rel='stylesheet';this.onload=null"
			href="https://unpkg.com/normalize.css@8.0.0/normalize.css">
		<link rel="stylesheet" rel="preload" as="style" onload="this.rel='stylesheet';this.onload=null"
			href="https://unpkg.com/milligram@1.3.0/dist/milligram.min.css">
	</head>

	<body>

		<main class="wrapper" style="padding-top:2em">

			<section class="container" id="demo-content">


				<div>
					<a class="button" id="startButton">Start</a>
					<a class="button" id="resetButton">Reset</a>
				</div>

				<div>
					<video id="video" width="300" height="200" style="border: 1px solid gray"></video>
				</div>

				<div id="sourceSelectPanel" style="display:none">
					<label for="sourceSelect">Change video source:</label>
					<select id="sourceSelect" style="max-width:400px">
					</select>
				</div>

				<label>Result:</label>
				<pre><code id="result"></code></pre>


			</section>


		</main>

		<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
		<script type="text/javascript" src="https://unpkg.com/@zxing/library@latest/umd/index.min.js"></script>
		<script type="text/javascript">
			let el = document.createElement('div');
			document.body.appendChild(el);

			eruda.init({
				container: el,
				tool: ['console', 'elements']
			});
			window.addEventListener('load', function () {
				let selectedDeviceId;
				const codeReader = new ZXing.BrowserMultiFormatReader()
				console.log('ZXing code reader initialized')
				codeReader.listVideoInputDevices()
					.then((videoInputDevices) => {
						const sourceSelect = document.getElementById('sourceSelect')
						selectedDeviceId = videoInputDevices[0].deviceId
						if (videoInputDevices.length >= 1) {
							videoInputDevices.forEach((element) => {
								const sourceOption = document.createElement('option')
								sourceOption.text = element.label
								sourceOption.value = element.deviceId
								sourceSelect.appendChild(sourceOption)
							})

							sourceSelect.onchange = () => {
								selectedDeviceId = sourceSelect.value;
							};

							const sourceSelectPanel = document.getElementById('sourceSelectPanel')
							sourceSelectPanel.style.display = 'block'
						}

						document.getElementById('startButton').addEventListener('click', () => {
							codeReader.decodeFromVideoDevice(selectedDeviceId, 'video', (result, err) => {
								if (result) {
									console.log(result)
									if (result.format === ZXing.BarcodeFormat.PDF_417) {
										console.log("=================> ZXing.BarcodeFormat.PDF_417")
										// Call the parser function.
										const parsedData = parsePDF417BCBP(result.text);

										console.log("--- Parsed BCBP Data (JSON Object) ---");
										console.log(JSON.stringify(parsedData, null, 2));
									}

									if (result.format === ZXing.BarcodeFormat.AZTEC) {
										console.log("=================> ZXing.BarcodeFormat.AZTEC")
										// Call the parser function.
										const parsedData = parseAZTECBCBP(result.text);

										console.log(JSON.stringify(parsedData, null, 2))
									}

									document.getElementById('result').textContent = result.text
								}
								if (err && !(err instanceof ZXing.NotFoundException)) {
									console.error(err)
									document.getElementById('result').textContent = err
								}
							})
							console.log(`Started continous decode from camera with id ${selectedDeviceId}`)
						})

						document.getElementById('resetButton').addEventListener('click', () => {
							codeReader.reset()
							document.getElementById('result').textContent = '';
							console.log('Reset.')
						})

					})
					.catch((err) => {
						console.error(err)
					})
			})

			/**
			* Parses a raw IATA BCBP (Bar Coded Boarding Pass) data string.
			* This parser is based on the fixed-length field structure of the IATA Resolution 792 standard.
			*
			* @param {string} bcbpString The raw data string from a PDF417 boarding pass barcode.
			* @returns {object|null} An object containing the parsed boarding pass data, or null if the input is invalid.
			*/
			function parsePDF417BCBP(bcbpString) {
				bcbpString = bcbpString.replace(/\s+/g, ' ');
				const compartmentMap = {
					'F': 'First Class',
					'J': 'Business Class',
					'C': 'Business Class',
					'Y': 'Economy/Coach Class',
					'W': 'Premium Economy'
				};
				// Step 1: Clean the raw string by removing all spaces. This is critical for correct indexing.
				const cleanedString = bcbpString.trim().split(" ");



				// Add a log to see the exact string being parsed. It should have no spaces.
				console.log("String length:", bcbpString.length);
				console.log("split:", cleanedString);
				console.log("raw:", bcbpString);

				// Step 2: Validate the string length. It must be at least 60 characters.
				if (bcbpString.length < 60 || !bcbpString.startsWith("M")) {
					console.error("ERROR: String is too short after cleaning. Check your input data.");
					return null;
				}

				// Step 3: Parse the data using the correct, standard character positions.
				try {
					const boardingPassData = "M1TOUCH/YARAVATTY E5XMARV PNHICNKE 0690 129Y048F0121 34D>5180 O5129BKE 2A18023965131220 KE N Q";
					//['M1TOUCH/YARAVATTY', 'E5XMARV', 'PNHICNKE', '0690', '129Y048F0121', '34D>5180', 'O5129BKE', '2A18023965131220', 'KE', 'N', 'Q']
					const data = {
						raw: bcbpString.trim(),
						mandatory: {
							formatCode: cleanedString[0].substring(0, 1),
							numberOfLegs: parseInt(cleanedString[0].substring(1, 2)),
							passengerName: cleanedString[0].substring(2, cleanedString[0].length).trim().replace('/', ' '),
							electronicTicketIndicator: cleanedString[1].substring(0, 1),
							pnrCode: cleanedString[1].trim().substring(2, cleanedString[1].length),
							fromCityAirportCode: cleanedString[2].substring(0, 3),
							toCityAirportCode: cleanedString[2].substring(3, 6),
							operatingCarrierDesignator: cleanedString[2].trim().substring(6, cleanedString[2].length),
							flightNumber: cleanedString[3].trim(),

							// --- PAY ATTENTION TO THESE LINES ---
							// The Julian Date is from character 44 up to (but not including) 47.
							dateOfFlight_Julian: cleanedString[4].substring(0, 3),

							// The Compartment Code is the single character at position 47.
							compartmentCode: compartmentMap[cleanedString[4].substring(3, 4)],

							// The Seat Number is the 4 characters from position 48 to 52.
							seatNumber: cleanedString[4].substring(4, 8).trim(),

							// The Check-in sequence is from 52 to 56.
							checkInSequenceNumber: cleanedString[4].trim().substring(8, cleanedString[4].length),
							// --- END OF ATTENTION AREA ---

							passengerStatus: cleanedString[5].substring(0, 1),
							fieldSizeOfVariableData: cleanedString[5].substring(1, 4),
						},
						conditional: {},
						security: {}
					};

					// Add interpreted, human-readable data
					const dayOfYear = parseInt(data.mandatory.dateOfFlight_Julian, 10);
					const year = new Date().getFullYear();
					const date = new Date(year, 0); // Start at Jan 1st
					data.mandatory.interpretedDate = new Date(date.setDate(dayOfYear)).toDateString();

					// Continue parsing conditional data if it exists

					console.log(data)
					return data;

				} catch (error) {
					console.error("An unexpected error occurred during parsing:", error);
					return null;
				}
			}


			/**
	 * Converts a Julian date (day of the year) to a Gregorian Date object.
	 * Assumes the current year. For flights booked far in advance, this might need adjustment.
	 * @param {string} julianDateStr - The day of the year as a string (e.g., "129").
	 * @returns {Date} The calculated Date object.
	 */
			function convertJulianDate(julianDateStr) {
				const dayOfYear = parseInt(julianDateStr, 10);
				const year = new Date().getFullYear(); // Assumes the flight is in the current year.
				const date = new Date(year, 0); // Start at Jan 1st
				return new Date(date.setDate(dayOfYear));
			}

			/**
			 * Parses the raw string from an IATA Bar Coded Boarding Pass (BCBP).
			 * @param {string} bcbpString The raw string from the decoded QR code.
			 * @returns {object} An object containing the parsed flight data.
			 */
			function parseAZTECBCBP(bcbpString) {
				// Check for a valid format before trying to parse
				if (bcbpString.length < 60 || !bcbpString.startsWith('M')) {
					return { error: "Invalid or unsupported BCBP data format." };
				}
				const compartmentMap = {
					'F': 'First Class',
					'J': 'Business Class',
					'C': 'Business Class',
					'Y': 'Economy/Coach Class',
					'W': 'Premium Economy'
				};
				const data = {};
				let offset = 0;

				// Use substring to slice the string at fixed positions defined by the IATA standard
				data.FormatCode = bcbpString.substring(offset, offset + 1); offset += 1;
				data.NumberOfLegs = parseInt(bcbpString.substring(offset, offset + 1), 10); offset += 1;
				data.PassengerName = bcbpString.substring(offset, offset + 20).trim().replace('/', " "); offset += 20;
				data.ElectronicTicket = bcbpString.substring(offset, offset + 1) === 'E' ? 'Yes' : 'No'; offset += 1;
				data.RecordLocator = bcbpString.substring(offset, offset + 7).trim(); offset += 7;
				data.FromCity = bcbpString.substring(offset, offset + 3).trim(); offset += 3;
				data.ToCity = bcbpString.substring(offset, offset + 3).trim(); offset += 3;
				data.OperatingCarrier = bcbpString.substring(offset, offset + 3).trim(); offset += 3;
				data.FlightNumber = bcbpString.substring(offset, offset + 5).trim(); offset += 5;

				const julianDate = parseInt(bcbpString.substring(offset, offset + 3).trim(), 10);
				data.FlightDate_Julian = julianDate;
				data.FlightDate_Calendar = convertJulianDate(julianDate); // Convert to readable date
				offset += 3;

				data.CompartmentCode = compartmentMap[bcbpString.substring(offset, offset + 1).trim()] || 'Unknown'; offset += 1;
				data.SeatNumber = bcbpString.substring(offset, offset + 4).trim(); offset += 4;
				data.CheckInSequence = bcbpString.substring(offset, offset + 5).trim(); offset += 5;
				data.PassengerStatus = bcbpString.substring(offset, offset + 1).trim(); offset += 1;
				console.log(data)
				return data;
			}
		</script>

	</body>

</html>